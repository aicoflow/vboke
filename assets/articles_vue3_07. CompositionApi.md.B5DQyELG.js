import{_ as e,c as a,o as i,aM as d}from"./chunks/framework.ldyE1wya.js";const k=JSON.parse('{"title":"CompositionApi","description":"","frontmatter":{},"headers":[],"relativePath":"articles/vue3/07. CompositionApi.md","filePath":"articles/vue3/07. CompositionApi.md"}'),s={name:"articles/vue3/07. CompositionApi.md"};function o(n,t,p,r,l,h){return i(),a("div",null,t[0]||(t[0]=[d(`<h1 id="compositionapi" tabindex="-1">CompositionApi <a class="header-anchor" href="#compositionapi" aria-label="Permalink to &quot;CompositionApi&quot;">​</a></h1><blockquote><p>面试题：composition api相比于option api有哪些优势？</p></blockquote><p>不同于reactivity api，composition api提供的函数很多是与组件深度绑定的，不能脱离组件而存在。</p><h1 id="setup" tabindex="-1">setup <a class="header-anchor" href="#setup" aria-label="Permalink to &quot;setup&quot;">​</a></h1><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">// component</span></span>
<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> {</span></span>
<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">props</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#FFAB70;">context</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">){</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // 该函数在组件属性被赋值后立即执行，早于所有生命周期钩子函数</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // props 是一个对象，包含了所有的组件属性值</span></span>
<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#6A737D;">    // context 是一个对象，提供了组件所需的上下文信息</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">}</span></span></code></pre></div><p>context对象的成员</p><table tabindex="0"><thead><tr><th>成员</th><th>类型</th><th>说明</th></tr></thead><tbody><tr><td>attrs</td><td>对象</td><td>同<code>vue2</code>的<code>this.$attrs</code></td></tr><tr><td>slots</td><td>对象</td><td>同<code>vue2</code>的<code>this.$slots</code></td></tr><tr><td>emit</td><td>方法</td><td>同<code>vue2</code>的<code>this.$emit</code></td></tr></tbody></table><h1 id="生命周期函数" tabindex="-1">生命周期函数 <a class="header-anchor" href="#生命周期函数" aria-label="Permalink to &quot;生命周期函数&quot;">​</a></h1><table tabindex="0"><thead><tr><th>vue2 option api</th><th>vue3 option api</th><th>vue 3 composition api</th></tr></thead><tbody><tr><td>beforeCreate</td><td>beforeCreate</td><td>不再需要，代码可直接置于setup中</td></tr><tr><td>created</td><td>created</td><td>不再需要，代码可直接置于setup中</td></tr><tr><td>beforeMount</td><td>beforeMount</td><td>onBeforeMount</td></tr><tr><td>mounted</td><td>mounted</td><td>onMounted</td></tr><tr><td>beforeUpdate</td><td>beforeUpdate</td><td>onBeforeUpdate</td></tr><tr><td>updated</td><td>updated</td><td>onUpdated</td></tr><tr><td>beforeDestroy</td><td>==改== beforeUnmount</td><td>onBeforeUnmount</td></tr><tr><td>destroyed</td><td>==改==unmounted</td><td>onUnmounted</td></tr><tr><td>errorCaptured</td><td>errorCaptured</td><td>onErrorCaptured</td></tr><tr><td>-</td><td>==新==renderTracked</td><td>onRenderTracked</td></tr><tr><td>-</td><td>==新==renderTriggered</td><td>onRenderTriggered</td></tr></tbody></table><p>新增钩子函数说明：</p><table tabindex="0"><thead><tr><th>钩子函数</th><th>参数</th><th>执行时机</th></tr></thead><tbody><tr><td>renderTracked</td><td>DebuggerEvent</td><td>渲染vdom收集到的每一次依赖时</td></tr><tr><td>renderTriggered</td><td>DebuggerEvent</td><td>某个依赖变化导致组件重新渲染时</td></tr></tbody></table><p>DebuggerEvent:</p><ul><li>target: 跟踪或触发渲染的对象</li><li>key: 跟踪或触发渲染的属性</li><li>type: 跟踪或触发渲染的方式</li></ul><h1 id="面试题参考答案" tabindex="-1">面试题参考答案 <a class="header-anchor" href="#面试题参考答案" aria-label="Permalink to &quot;面试题参考答案&quot;">​</a></h1><p>面试题：composition api相比于option api有哪些优势？</p><blockquote><p>从两个方面回答：</p><ol><li>为了更好的逻辑复用和代码组织</li><li>更好的类型推导</li></ol></blockquote><div class="language- vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang"></span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span>有了composition api，配合reactivity api，可以在组件内部进行更加细粒度的控制，使得组件中不同的功能高度聚合，提升了代码的可维护性。对于不同组件的相同功能，也能够更好的复用。</span></span>
<span class="line"><span>相比于option api，composition api中没有了指向奇怪的this，所有的api变得更加函数式，这有利于和类型推断系统比如TS深度配合。</span></span></code></pre></div>`,17)]))}const u=e(s,[["render",o]]);export{k as __pageData,u as default};
